package epaper_test

import (
	"bytes"
	"fmt"
	"testing"

	"github.com/otaviokr/go-epaper-lib"
	"periph.io/x/periph/conn/gpio"
)

var (
	// ModelSim represents a black-and-white 10x10 pixel display
	ModelSim = epaper.Model{Width: 10, Height: 20, StartTransmission: 0x13}

	ExpectedInitResult = []byte{
		0x01, 0x03, 0x00, 0x2B, 0x2B, 0x09, 0x06, 0x07, 0x07, 0x17, 0xf8, 0x60, 0xa5, 0xf8, 0x89, 0xa5, 0xf8, 0x90,
		0x00, 0xf8, 0x93, 0x2a, 0xf8, 0xa0, 0xa5, 0xf8, 0xa1, 0x00, 0xf8, 0x73, 0x41, 0x16, 0x00, 0x04, 0x00, 0xaf,
		0x30, 0x3a, 0x82, 0x12, 0x20, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x00, 0x32, 0x32, 0x00, 0x00,
		0x02, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x50, 0x0f, 0x0f, 0x00,
		0x00, 0x05, 0x60, 0x32, 0x32, 0x00, 0x00, 0x02, 0xa0, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x22, 0x50, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x60, 0x32, 0x32, 0x00, 0x00, 0x02, 0xa0, 0x0f, 0x0f,
		0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xa0, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x60, 0x32,
		0x32, 0x00, 0x00, 0x02, 0x50, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xa0,
		0x0f, 0x0f, 0x00, 0x00, 0x05, 0x60, 0x32, 0x32, 0x00, 0x00, 0x02, 0x50, 0x0f, 0x0f, 0x00, 0x00, 0x05, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00,
	}

	ExpectedClearScreenResult = []byte{
		0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x12,
	}
)

func validateByteSlice(input, expected []byte, detail string) string {
	if len(input) != len(expected) {
		return fmt.Sprintf("Input and expected sizes for %s: input = %d and expected = %d", detail, len(input), len(expected))
	}
	for i := 0; i < len(input); i++ {
		if input[i] != expected[i] {
			return fmt.Sprintf("Failed on %s, expected value at index %d: expected %d but found %d", detail, i, expected[i], input[i])
		}
	}
	return ""
}

func TestNewFailErrors(t *testing.T) {
	output, err := epaper.New(ModelSim)
	if err == nil {
		t.Fatal("Expected to fail, because no device is attached")
	}

	if output != nil {
		t.Fatal("Expected to fail, but Object is not nil")
	}
}

func TestNewCustomFailErrors(t *testing.T) {
	output, err := epaper.NewCustom("", "", "", "", ModelSim, false, nil)
	if err == nil {
		t.Fatal("Expected to fail, because no device is attached")
	}

	if output != nil {
		t.Fatal("Expected to fail, but Object is not nil")
	}
}

func TestSleep(t *testing.T) {
	expectedSleepResult := []byte{0x02, 0x07, 0xa5}
	// Create a dummy "epaper"
	// (to create a real one, use the example source code, this won't work!)
	debug := new(bytes.Buffer)
	e, err := epaper.NewCustom("", "", "", "", ModelSim, true, debug)
	if err != nil {
		t.Fatal(err)
	}

	// Forcing the BUSY to High to avoid being blocked because of WaitUntilIdle().
	// Do not do this on real cases!
	e.Busy.Out(gpio.High)

	e.Sleep()

	// Resetting BUSY...
	e.Busy.Out(gpio.Low)

	// Validating data sent to dummy device.
	errorMsg := validateByteSlice(debug.Bytes(), expectedSleepResult, "Input function")
	if len(errorMsg) > 0 {
		t.Fatal(errorMsg)
	}
	debug.Reset()
}
